generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserType {
  MICROSOFT
  EMAIL
}

model User {
  id String @id @unique @default(uuid()) // Unique user ID. Also used as DID store ID to retrieve the DID store.

  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @default(now())
  lastSeenAt         DateTime  @default(now()) // Updated every time the user uses the app
  welcomeEmailSentAt DateTime? // Date at which the welcome email was sent, if any

  type UserType

  // Auth process
  temporaryEmailAuthKey       String? // Temporary authentication key generated for authentication by email address + magic "link"
  temporaryEmailAuthExpiresAt DateTime? // Date at which temporaryEmailAuthKey becomes invalid and cannot be used to confirm email sign in by magic link.

  ProfileEntries ProfileEntry[]
  IdentityRoot   IdentityRoot[]
  Identity       Identity[]
  UserShadowKey  UserShadowKey[]
  Device         Device[]
}

// Corresponds to a RootIdentity in the DID SDK, meaning one mnemonic.
// We can choose to reuse existing IdentityRoots when creating new Identities, meaning
// That the new Identity/DID is derived from the same mnemonic (more convenient to users).
// Or we can create a new IdentityRoot, meaning the new identity is created with a new mnemonic (better separation, transferability).
model IdentityRoot {
  id String @id @unique @default(uuid())

  createdAt              DateTime @default(now())
  user                   User     @relation(fields: [userId], references: [id], onDelete: Restrict)
  didStoreRootIdentityId String // Unique id of the matching RootIdentity in the DID SDK, to retrieve the root mnemonic used to derive new DIDs

  userId   String
  Identity Identity[]
}

model Identity {
  did String @unique

  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @default(now())
  user            User         @relation(fields: [userId], references: [id], onDelete: Restrict)
  identityRoot    IdentityRoot @relation(fields: [identityRootId], references: [id], onDelete: Restrict)
  derivationIndex Int // Informative, for users: index of the DID derivation in the DID SDK

  userId         String
  identityRootId String

  credentials Credential[]
}

// Metadata for Verifiable Credentials, with additional information
model Credential {
  id String @id @unique @default(uuid()) // This ID never changes so we can for example attach permanent UI properties to it

  createdAt    DateTime @default(now())
  identity     Identity @relation(fields: [identityDid], references: [did], onDelete: Restrict)
  credentialId String // ID of the real credential, that changes when "updating" the data (actually, delete and create a new VC)

  // TODO: save the full credential types for easy query by type later

  identityDid String // Related identity
}

enum IntentType {
  REQUEST_CREDENTIALS
  IMPORT_CREDENTIALS
}

// Request received from a third party app (through the did web connectivity sdk connector)
// to interact with the identity wallet, for example, to request credentials, or import credentials.
model Intent {
  id String @id @unique @default(uuid())

  createdAt DateTime   @default(now()) // Time of the initial intent request (creation)
  type      IntentType

  requestPayload  Json // Raw payload received by the requesting app
  responsePayload Json? // Raw response ready to return, or returned to the requesting app
}

model ProfileEntry {
  id String @id @unique @default(uuid())

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  user      User    @relation(fields: [userId], references: [id], onDelete: Restrict)
  type      String // Firstname, lastname, avatar, location, company, emails, phone numbers, etc.
  title     String?
  value     String
  visible   Boolean @default(false)
  isPrimary Boolean @default(false) // Such as email, many email addresses, one can be set primary.
  internal  Boolean @default(false) // If true, the profile entry is never provided to the front end. For internal back end use only.

  userId String

  @@unique([userId, type, title])
}

enum UserShadowKeyType {
  PUBLICKEY
  PASSWORD
}

// Encrypted versions of the main "user account key"s (one per user),
// using keypairs specific to each user device. These are shadow copies
// of the account key, this is why they are named UserShadowKeys.
// For better adoption, users start by using a password, so a password mode is supported,
// but this is less safe (users use similar password everywhere so the chances of leaks are high).
// The UI will recommend to get rid of the basic passwords as user binds more devices, which is necessary to
// recover the account key (no other way to restore if all device keypairs are lost).
model UserShadowKey {
  id String @id @unique @default(uuid())

  createdAt           DateTime          @default(now())
  user                User              @relation(fields: [userId], references: [id], onDelete: Restrict)
  type                UserShadowKeyType
  encryptedAccountKey String // Root account key encrypted by this shadow key
  publicKey           String? // For publickey types, this is the keypair public key to know which shadow key entry we should try to use to decrypt.
  passwordHash        String? // One way hash of the password, for password types only
  device              Device?           @relation(fields: [deviceId], references: [id], onDelete: Restrict) // For publickey types, this is the related device entity for which this shadow key was generated

  userId   String
  deviceId String
}

// Bound user device
model Device {
  id String @id @unique @default(uuid())

  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Restrict)
  userAgent String // Browser user agent raw string as provided when binding the device
  name      String // Device name, originally auto defined from the user agent, later optionally configured by users

  userId        String
  UserShadowKey UserShadowKey[]
}
