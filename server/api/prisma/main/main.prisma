generator client {
  provider = "prisma-client-js"
  output   = "../../node_modules/@prisma/client/main"
}

datasource db {
  provider = "postgresql"
  url      = env("MAIN_DATABASE_URL")
}

model User {
  id       String  @id @unique @default(uuid()) // Unique user ID. Also used as DID store ID to retrieve the DID store.
  name     String?
  fullName String? // '${firstname}, ${lastname}'

  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @default(now())
  lastSeenAt         DateTime  @default(now()) // Updated every time the user uses the app
  welcomeEmailSentAt DateTime? // Date at which the welcome email was sent, if any

  defaultRootIdentityId String? // This is a prisma IdentityRoot.id

  IdentityRoot            IdentityRoot[]
  Identity                Identity[]
  UserShadowKey           UserShadowKey[]
  Device                  Browser[]
  Activities              Activity[]
  UserEmails              UserEmail[]
  DeveloperAccessKey      DeveloperAccessKey[]
  TemporaryAuthentication TemporaryAuthentication[]
}

// Temporary sign in link/pin code to access a user account by email magic link, or directly by sharing
// urls to another device. PIN code is visually displayed and needs to be confirmed by user to validate.
model TemporaryAuthentication {
  id String @id @unique @default(uuid())

  user      User     @relation(fields: [userId], references: [id], onDelete: Restrict) // Initiating user
  authKey   String // Temporary authentication key generated for authentication by email address/sign in url
  expiresAt DateTime // Date at which temporaryEmailAuthKey becomes invalid and cannot be used to sign in
  pinHash   String // One way PIN code hash to verify user's typed PIN on the signing device.

  temporaryEmail String? // Temporary email address used to bind to user, if any.

  userId String
}

enum UserEmailProvider {
  RAW
  MICROSOFT
  GOOGLE
  LINKEDIN
}

model UserEmail {
  id        String            @id @unique @default(uuid()) // Unique user ID. Also used as DID store ID to retrieve the DID store.
  user      User              @relation(fields: [userId], references: [id], onDelete: Restrict)
  email     String            @unique
  provider  UserEmailProvider
  createdAt DateTime          @default(now())

  userId String

  activities Activity[]
}

// Corresponds to a RootIdentity in the DID SDK, meaning one mnemonic.
// We can choose to reuse existing IdentityRoots when creating new Identities, meaning
// That the new Identity/DID is derived from the same mnemonic (more convenient to users).
// Or we can create a new IdentityRoot, meaning the new identity is created with a new mnemonic (better separation, transferability).
model IdentityRoot {
  id String @id @unique @default(uuid())

  createdAt              DateTime @default(now())
  user                   User     @relation(fields: [userId], references: [id], onDelete: Restrict)
  didStoreRootIdentityId String // Unique id of the matching RootIdentity in the DID SDK, to retrieve the root mnemonic used to derive new DIDs

  userId   String
  Identity Identity[]
}

enum IdentityType {
  REGULAR // Regular identity for standard users to represent themselves
  APPLICATION // Identity to represent applications, for developers
}

model Identity {
  did String @unique

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now())
  lastUsedAt  DateTime  @default(now())
  publishedAt DateTime?

  user                User         @relation(fields: [userId], references: [id], onDelete: Restrict)
  identityRoot        IdentityRoot @relation(fields: [identityRootId], references: [id], onDelete: Restrict)
  derivationIndex     Int // Informative, for users: index of the DID derivation in the DID SDK
  type                IdentityType @default(REGULAR)
  creatingAppIdentity Identity?    @relation("createdAppIdentities", fields: [creatingAppIdentityDid], references: [did], onDelete: Restrict) // If any, application used to create this regular identity

  userId                 String
  identityRootId         String
  publicationId          String?
  creatingAppIdentityDid String?

  credentials                    Credential[]
  activities                     Activity[]
  IdentityInteractingApplication IdentityInteractingApplication[]
  IdentityClaimRequest           IdentityClaimRequest[]
  createdAppIdentities           Identity[]                       @relation("createdAppIdentities")
}

// Metadata for Verifiable Credentials, with additional information
model Credential {
  id String @id @unique @default(uuid()) // This ID never changes so we can for example attach permanent UI properties to it

  createdAt    DateTime                        @default(now())
  identity     Identity                        @relation(fields: [identityDid], references: [did], onDelete: Restrict)
  credentialId String // ID of the real credential, that changes when "updating" the data (actually, delete and create a new VC)
  importedBy   IdentityInteractingApplication? @relation(fields: [importedById], references: [id], onDelete: Restrict) // If the credential was imported and we know the app that did it, that's the info about that app

  // TODO: save the full credential types for easy query by type later

  identityDid  String // Related identity
  importedById String?

  RequestedCredentials RequestedCredential[]
}

enum IntentType {
  REQUEST_CREDENTIALS
  IMPORT_CREDENTIALS
}

// Request received from a third party app (through the Mydentity connectivity sdk connector)
// to interact with the identity wallet, for example, to request credentials, or import credentials.
model Intent {
  id String @id @unique @default(uuid())

  createdAt   DateTime   @default(now()) // Time of the initial intent request (creation)
  fulfilledAt DateTime?
  type        IntentType

  redirectUrl     String // URL (original dapp) where we to redirect user after getting a response from the web service.
  requestPayload  Json // Raw payload received by the requesting app
  responsePayload Json? // Raw response ready to return, or returned to the requesting app
}

enum UserShadowKeyType {
  PASSWORD
  WEBAUTHN
}

// Encrypted versions of the main "user account key"s (one per user),
// using keypairs specific to each user device. These are shadow copies
// of the account key, this is why they are named UserShadowKeys.
// For better adoption, users start by using a password, so a password mode is supported,
// but this is less safe (users use similar password everywhere so the chances of leaks are high).
// The UI will recommend to get rid of the basic passwords as user binds more devices, which is necessary to
// recover the account key (no other way to restore if all device keypairs are lost).
model UserShadowKey {
  user   User   @relation(fields: [userId], references: [id], onDelete: Restrict)
  userId String

  keyId        String
  key          String // For publickey types, this is the keypair public key to decrypt the SecretKey; for password type, this is the hash of the password.
  credentialId String?
  counter      Int?
  type         UserShadowKeyType
  secretKey    String // Root account SecretKey encrypted by this public key or password

  browser   Browser? @relation(fields: [browserId], references: [id], onDelete: Restrict) // For publickey types, this is the related browser entity for which this shadow key was generated
  browserId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  @@id([userId, keyId])
}

// Browser used to access the service
// The same browser used by 2 different users are seen as 2 different browsers here.
model Browser {
  id String @id @unique @default(uuid())

  createdAt  DateTime @default(now())
  lastUsedAt DateTime @default(now())

  key       String // Client device uuid (stored in local storage) to better match a browser even after update (user agent change) or when access token is renewed.
  userAgent String // Browser user agent raw string as provided when binding the device. This is purely informative as a browser update can make this change
  name      String // Device name, originally auto defined from the user agent, later optionally configured by users
  user      User   @relation(fields: [userId], references: [id], onDelete: Restrict)

  userId        String
  UserShadowKey UserShadowKey[]
  Activities    Activity[]

  // @@id([userId, clientId])
}

enum ActivityType {
  NEW_ACCOUNT
  USER_SIGN_IN
  IDENTITY_CREATED
  IDENTITY_DELETED
  CREDENTIALS_IMPORTED
  CREDENTIALS_SHARED // Also credentials request
  BIND_EMAIL
  BIND_BROWSER
  PASSWORD_CHANGED
}

model Activity {
  id   String       @id @unique @default(uuid())
  user User         @relation(fields: [userId], references: [id], onDelete: Restrict)
  type ActivityType

  userEmail         UserEmail?         @relation(fields: [userEmailId], references: [id]) // For BIND_EMAIL.
  userEmailProvider UserEmailProvider? // For USER_SIGN_IN or BIND_EMAIL.
  // May not the same as userEmail.provider. For example, MS email, but sign-in by auth key.
  userEmailAddress  String? // For BIND_EMAIL.
  identity          Identity?          @relation(fields: [identityId], references: [did]) // For IDENTITY_CREATED
  identityDid       String? // For IDENTITY_CREATED and IDENTITY_DELETED.
  credentialsCount  Int? // For CREDENTIALS_IMPORTED and CREDENTIALS_SHARED.
  appDid            String? // Caller of CREDENTIALS_IMPORTED and CREDENTIALS_SHARED.
  browser           Browser?           @relation(fields: [browserId], references: [id], onDelete: Restrict) // For BIND_BROWSER, if no browser, use browserName
  browserName       String? // For BIND_BROWSER

  createdAt DateTime @default(now())

  userId      String
  browserId   String?
  identityId  String?
  userEmailId String?
}

// No need setup the relations with the user
model AuthChallenge {
  id        String   @id @unique @default(uuid())
  content   String
  createdAt DateTime @default(now())
}

// Third party application that interacted with our service to import credentials, request credentials, etc
// An interacting application entry is shared by the whole service (all users share the same - so we can handle global
// stats about an app, possibly cache some info).
model InteractingApplication {
  id        String   @id @unique @default(uuid())
  createdAt DateTime @default(now())

  did String @unique // Application DID of the calling app. This DID is purely informative (given by the app), it's not been verified

  IdentityInteractingApplication IdentityInteractingApplication[]
}

// Mapping between an identity and an application that interacted with it
model IdentityInteractingApplication {
  id        String   @id @unique @default(uuid())
  createdAt DateTime @default(now())

  identity               Identity               @relation(fields: [identityDid], references: [did], onDelete: Restrict)
  interactingApplication InteractingApplication @relation(fields: [interactingApplicationId], references: [id], onDelete: Restrict)

  identityDid              String
  interactingApplicationId String

  ImportedCredentials Credential[]
  RequestedCredential RequestedCredential[]

  @@unique([identityDid, interactingApplicationId])
}

// Mapping of interacting application with credentials they requested to users. This way we can
// show users which of their credentials where shared to which third party app.
model RequestedCredential {
  id        String   @id @unique @default(uuid())
  createdAt DateTime @default(now())

  credential             Credential                     @relation(fields: [credentialId], references: [id], onDelete: Restrict)
  interactingApplication IdentityInteractingApplication @relation(fields: [interactingApplicationId], references: [id], onDelete: Restrict)

  credentialId             String
  interactingApplicationId String

  @@unique([credentialId, interactingApplicationId])
}

// Developer access key to programatically call our service API npmfrom third party apps.
// This includes the ability to manage his account, create managed identities for others, issue credentials to manage identities, etc.
// In theory, a developer can have multiple access keys, but the UI may allow
// only one access key at a time initially.
model DeveloperAccessKey {
  id        String   @id @unique @default(uuid())
  createdAt DateTime @default(now())

  user  User    @relation(fields: [userId], references: [id], onDelete: Restrict) // User for which this access key is
  hash  String // Hashed access key (not in cleartext)
  title String? // Friendly title for developer to remember what the key is for

  userId String

  @@unique([hash]) // Very important: make sure 2 keys don't get the same value by chance, otherwise we would give access to the wrong user.
}

// Request made by the current temporary identity owner (third party app who created a managed identity)
// to give access to this identity to a user. The claim request is valid only during a short time, during
// which the user needs to go to the Mydentity app and complete the claim request.
model IdentityClaimRequest {
  id               String    @id @unique @default(uuid())
  createdAt        DateTime  @default(now())
  expiresAt        DateTime? // Date at which temporaryEmailAuthKey becomes invalid and cannot be used to confirm email sign in by magic link.
  claimCompletedAt DateTime?

  identity    Identity @relation(fields: [identityDid], references: [did], onDelete: Restrict)
  identityDid String

  password String // encrypted password with nonce
}
