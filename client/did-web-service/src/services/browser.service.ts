import jwtDecode from "jwt-decode";
import { logger } from "./logger";
import { AccessTokenPayload } from "./user/access-token-payload";
import { signOut } from "./user/user.service";

const BROWSER_ID_STORAGE_KEY = "browser-client-id";

/**
 * If we have no browser id saved yet, update browser ID from the access token when we get a new access token. This is because the browser ID
 * is generated by the backend, and returned to use in the JWT token after authentication. As this browser ID is sent back
 * to the backend with every GQL API calls, the server doesn't generate a new browser id any more.
 */
export function checkNewAccessTokenForBrowserId(accessToken: string) {
  let decodedToken: AccessTokenPayload;
  try {
    decodedToken = jwtDecode(accessToken);
  }
  catch (e) {
    logger.error("browser", "Access token received from the backend cannot be decoded!");
    return;
  }

  if (!decodedToken.browserId)
    throw new Error("Abnormal state: no browser ID found in the access token!");

  const existingBrowserId = getBrowserId();
  if (existingBrowserId) {
    // If we already have a browser id in local storage, but the browser id packaged in the
    // access token is not the same, this is weird. This can either be a state bug (dev bug) or
    // an attempt to reuse a stolen access token in another browser. If this is the case, we
    // throw an error for now (mostly dev bug).
    if (existingBrowserId !== decodedToken.browserId) {
      deleteBrowserId();
      signOut()
      throw new Error(`State error! Browser ID ${existingBrowserId} is different from access token browser ID ${decodedToken.browserId} !`);
    }
  }

  setBrowserId(decodedToken.browserId);
}

export function getBrowserId(): string {
  return localStorage.getItem(BROWSER_ID_STORAGE_KEY);
}

export function setBrowserId(browserId: string) {
  localStorage.setItem(BROWSER_ID_STORAGE_KEY, browserId);
}

export function deleteBrowserId() {
  localStorage.removeItem(BROWSER_ID_STORAGE_KEY);
}